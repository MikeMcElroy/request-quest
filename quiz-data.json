[{"title":"Simple image element","subtitle":"Is img.png requested?","lang":"html","expectedRequest":"img.png","phases":[{"addLines":["<div style=\"display: none\"><img src=\"img.png\"></div>"]},{"removeLines":1,"addLines":["<img src=\"img.png\" style=\"display: none\">"]},{"removeLines":1,"addLines":["<img src=\"img.png\" style=\"visibility: hidden\">"]},{"removeLines":1,"addLines":["<img src=\"img.png\">"]},{"addLines":["<p>Abracadabra!</p>"]},{"addLines":["<xhr url=\"img.png\"/>"]},{"addLines":["<p>I'm just making stuff up now</p>"]},{"addLines":["<p>You totally missed the request</p>"]}],"id":"img-element","answer":{"chrome":0,"opera":0,"firefox":0,"ie":0},"explanation":"<p>Browsers download imagery regardless of style, <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/embedded-content-1.html#dfnReturnLink-0\">as per the spec</a>.</p>\n\n<p>This behaviour has been the downfall of many JavaScript implementations of adaptive imagery, as the original image gets requested before JavaScript can jump in and alter the <code>src</code> property.</p>"},{"title":"Background Images","subtitle":"Is img.png requested?","lang":"html","expectedRequest":"img.png","phases":[{"addLines":["<div style=\"display:none\">","  <div style=\"background: url(img.png)\"></div>","</div>"]},{"removeLines":3,"addLines":["<div style=\"background: url(img.png); display: none\"></div>"]},{"removeLines":1,"addLines":["<div style=\"background: url(img.png); visibility: hidden\"></div>"]},{"removeLines":1,"addLines":["<div style=\"background: url(img.png); opacity: 0\"></div>"]},{"removeLines":1,"addLines":["<div style=\"background: url(img.png);\"></div>"]}],"id":"divbg-element","answer":{"chrome":1,"opera":2,"firefox":2,"ie":1},"explanation":"<p>CSS background images differ from <code>img</code> elements, they aren't downloaded as soon as the element is parsed.</p>\n\n<p>If an element has <code>display: none</code>, calculating styles within that element is a waste of time since have no impact on the rendering of the document (they're not displayed), so background images on child elements are never calculated and therefore not downloaded.</p>\n\n<p>Browsers differ when it comes to an element that has its style calculated, but is hidden as a result. IE and Chrome download the image even though it won't be rendered. This suggests that IE and Chrome trigger background image requests when styles are calculated, whereas Firefox and Opera wait until the element is laid out on the page. The Firefox and Opera behaviour is arguably more consistent and optimal in terms of downloads.</p>\n\n<p>Although <code>visibility: hidden</code> and <code>opacity: 0</code> makes the background invisible to the user, the element's layout is still calculated, therefore Firefox and Opera download the background.</p>\n\n<p><strong>TODO:</strong> Anything in the spec(s) about this?</p>"},{"title":"Creating an image element with js","subtitle":"Is img.png requested?","lang":"js","expectedRequest":"img.png","phases":[{"addLines":["var img = document.createElement('img');","img.src = 'img.png';"]},{"addLines":["document.body.appendChild(img);","document.body.removeChild(img);"]},{"removeLines":1}],"id":"img-add","answer":{"chrome":0,"opera":0,"firefox":0,"ie":0},"explanation":"<p><code>img</code> sources are downloaded <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/embedded-content-1.html#dfnReturnLink-0\">as soon as their <code>src</code> attribute is set</a>. There's no requirement for them to be in a document.</p>\n\n<p>If you need to quickly trigger an http request and don't care about the response, you can do so with <code>new Image().src = url;</code>.</p>"},{"title":"Elements with background images created via script","subtitle":"Is img.png requested?","lang":"js","expectedRequest":"img.png","phases":[{"addLines":["var div = document.createElement('div');","div.style.background = 'url(img.png)';"]},{"addLines":["document.body.appendChild(div);","document.body.removeChild(div);"]},{"removeLines":1,"addLines":["div.style.background;","document.body.removeChild(div);"]},{"removeLines":2,"addLines":["div.innerHTML;","document.body.removeChild(div);"]},{"removeLines":2,"addLines":["div.offsetWidth;","document.body.removeChild(div);"]},{"removeLines":2}],"id":"divbg-add","answer":{"chrome":4,"opera":5,"firefox":4,"ie":3},"explanation":"<p>As we've seen with plain HTML, background images aren't downloaded until their style is calculated or laid out (depending on the browser). There's no point doing either of those until the element is in a document.</p>\n\n<p>Inserting and removing an element changes the DOM twice, but since the page isn't rendered in-between (JavaScript blocks the rendering thread) the element's styles are never calculated, nor is it laid out.</p>\n\n<p>Calculating the <code>offsetWidth</code> of an element triggers layout which triggers style computation. As we saw earlier, this triggers downloads in Chrome and Firefox. Opera however, doesn't download the image at this point, suggesting it doesn't trigger background-image downloads unless layout is triggered as part of rendering.</p>\n\n<p>The download is triggered earlier in IE, by reading <code>innerHTML</code>. This is unusual as <code>innerHTML</code> doesn't depend on style at all.</p>\n\n<p><strong>TODO:</strong> Anything in the spec(s) about this?</p>"},{"title":"Script elements","subtitle":"Is script.js requested?","lang":"html","expectedRequest":"script.js","phases":[{"addLines":["<script src=\"script.js\" type=\"foo/bar\"></script>"]},{"removeLines":1,"addLines":["<script src=\"script.js\" type=\"script/dart\"></script>"]},{"removeLines":1,"addLines":["<script src=\"script.js\" type=\"text/html\"></script>"]},{"removeLines":1,"addLines":["<script src=\"script.js\" LANGUAGE=DART></script>"]},{"removeLines":1,"addLines":["<script src=\"script.js\"></script>"]},{"removeLines":1,"addLines":["<script src=\"script.js\" type=\"script/javascript\"></script>"]}],"id":"script-element","answer":{"chrome":4,"opera":0,"firefox":0,"ie":0},"explanation":"<p>None of the browsers parse scripts of a type/language they don't recognise, but Firefox, IE and Opera <em>will</em> download the file regardless of type.</p>\n\n<p><a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#script-processing-prepare\">The HTML spec</a> instructs browsers to ignore script elements with an unsupported type, Chrome follows this rule whereas the others don't.</p>\n\n<p>If a script element lacks a type/language attribute, <code>text/javascript</code> is assumed. This is common browser behaviour and was <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#script-processing-prepare\">later added to the HTML spec</a></p>\n\n<p>Interestingly, <a href=\"http://blog.getify.com/on-script-loaders/\">some script preloaders relied on browsers downloading unrecognised script types</a> in order to populate the cache, which no longer works in Chrome.</p>"},{"title":"Dynamic script loading","subtitle":"Is script.js requested?","lang":"js","expectedRequest":"script.js","phases":[{"addLines":["var script = document.createElement('script');","script.src = 'script.js';"]},{"addLines":["document.body.appendChild(script);","document.body.removeChild(script);"]},{"removeLines":1}],"id":"script-add","answer":{"chrome":1,"opera":2,"firefox":1,"ie":0},"explanation":"<p>Ahh the joys of cross-browser development! Here's what <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#dfnReturnLink-0\">the spec</a> has to say:</p>\n\n<blockquote>\n  <p>When a script element … experiences one of the events listed … the user agent must synchronously prepare the script element:</p>\n  \n  <p>The script element gets inserted into a document…</p>\n</blockquote>\n\n<p>Script preparation involves triggering the request.</p>\n\n<p>IE is violating the spec by triggering the request before the script is inserted into the document. Opera violates the spec by asynchronously handling script preparation, waiting until the end of script execution to prepare new scripts.</p>"},{"title":"Creating a link element via script","subtitle":"Is style.css requested?","lang":"js","expectedRequest":"style.css","phases":[{"addLines":["var link = document.createElement('link');","link.rel = 'stylesheet';","link.href = 'style.css';"]},{"addLines":["link.type = 'text/javascript';","document.body.appendChild(link);","document.body.removeChild(link);"]},{"removeLines":1},{"removeLines":2,"addLines":["document.body.appendChild(link);","document.body.removeChild(link);"]},{"removeLines":1},{"removeLines":1,"addLines":["document.querySelector('head').appendChild(link)"]}],"id":"style-add","answer":{"chrome":1,"opera":4,"firefox":3,"ie":3},"explanation":"<p>According to <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/links.html#link-type-stylesheet\">the spec</a>…</p>\n\n<blockquote>\n  <p>The appropriate time to obtain the resource is when the external resource link is created or when its element is inserted into a document, whichever happens last.</p>\n</blockquote>\n\n<p>…so we wouldn't expect to see a request before the <code>link</code> was added to the document.</p>\n\n<p>The specification doesn't cover what to do if the content-type is unsupported for styles, but it's unexpected to see Chrome making the request at this point. Note: it doesn't parse the styles, it just downloads the file.</p>\n\n<blockquote>\n  <p>The default type for resources given by the stylesheet keyword is text/css.</p>\n</blockquote>\n\n<p>…so the lack of a <code>type</code> attribute doesn't prevent downloading. Once again we see Opera deferring adding downloads to the queue until scripts have finished.</p>"},{"title":"Iframes","subtitle":"Is anything from the host domain requested? Assume the host page location is `/index.html?search=stuff`","lang":"html","expectedRequest":"#","phases":[{"addLines":["<iframe></iframe>"]},{"removeLines":1,"addLines":["<iframe src=\"\"></iframe>"]},{"removeLines":1,"addLines":["<iframe src=\"#\"></iframe>"]},{"removeLines":1,"addLines":["<iframe src=\"?\"></iframe>"]}],"id":"iframe-element","answer":{"chrome":2,"opera":3,"firefox":3,"ie":3},"explanation":"<p>The <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-iframe-element.html#process-the-iframe-attributes\">spec is clear</a> about handling iframes without src element, or empty src elements:</p>\n\n<blockquote>\n  <p>if the element has no src attribute specified… fire a simple event named load at the iframe element.</p>\n</blockquote>\n\n<p>A load event is fired even though nothing is loaded.</p>\n\n<blockquote>\n  <p>Otherwise if the value of the src attribute is the empty string, let url be the string \"about:blank\".</p>\n</blockquote>\n\n<p>…so no requests there.</p>\n\n<blockquote>\n  <p>Otherwise, resolve the value of the src attribute, relative to the iframe element.</p>\n</blockquote>\n\n<p>…so both \"#\" and \"?\" map to urls on the host domain. Except…</p>\n\n<blockquote>\n  <p>If there exists an ancestor browsing context whose active document's address, ignoring fragment identifiers, is equal to url, then abort these steps.</p>\n</blockquote>\n\n<p>Chrome violates this part of the spec. \"#\" is the same url as the parent window if the fragment identifier is ignored.</p>\n\n<p>\"?\" is a different url to the parent window, so a request is triggered.</p>"},{"title":"Altering the DOM with document.write","subtitle":"Is img.png requested?","lang":"html","expectedRequest":"img.png","phases":[{"addLines":["<script>document.write('<'+'!--')</script>","<img src=\"img.png\">","-->"]},{"removeLines":3,"addLines":["<script async>document.write('<'+'!--')</script>","<img src=\"img.png\">","-->"]},{"removeLines":3,"addLines":["<script defer>document.write('<'+'!--')</script>","<img src=\"img.png\">","-->"]},{"removeLines":2,"addLines":["-->","<img src=\"img.png\">","-->"]},{"removeLines":1}],"id":"script-comment","answer":{"chrome":3,"opera":3,"firefox":0,"ie":0},"explanation":"<p>This is a tricky one.</p>\n\n<p>If an HTML comment is written, the <code>img</code> element isn't parsed &amp; therefore shouldn't download. However, some browsers optimise by looking ahead and identifying extra requests to make, reducing the performance impact of elements that block parsing, such as inline scripts. This is known as <a href=\"https://developer.mozilla.org/en-US/docs/HTML/Optimizing_Your_Pages_for_Speculative_Parsing\">speculative parsing</a>.</p>\n\n<p>Firefox and IE continue to parse the document while the script is executing, they pick up the <code>img</code> and trigger a request. The script finishes and the speculative parsing work is discarded along with the <code>img</code> element, an html comment is created in its place, but the request has already been made.</p>\n\n<p>Chrome and Opera also speculatively parse, but not in the case of inline scripts.</p>\n\n<p>The <code>async</code> and <code>defer</code> attributes <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#script-processing-defer\">have no effect</a> on inline scripts. They were just to throw you off the scent. Sorry.</p>"},{"title":"Reloading the page","subtitle":"Is the page reloaded? Assume the user does not resize the page.","lang":"js","expectedRequest":"#","phases":[{"addLines":["window.onresize = function() {","  window.location.reload();","};"]},{"addLines":["var event = document.createEvent('Event');","event.initEvent('resize', false, false);","window.dispatchEvent(event);"]},{"removeLines":3,"addLines":["window.onresize();"]}],"id":"resize-reload","answer":{"chrome":1,"opera":1,"firefox":2,"ie":1},"explanation":"<p>This seems straight forward at first. Triggering the resize event should cause the page to reload right? No, this is a <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html#dom-location-reload\">spec violation</a>!</p>\n\n<blockquote>\n  <p>When the reload() method is invoked … If the currently executing task is the dispatch of a resize event in response to the user resizing the browsing context … Repaint the browsing context and abort these steps.</p>\n</blockquote>\n\n<p>Although the test isn't strictly 'in response to the user resizing', the results are the same as if they were.</p>\n\n<p>So, why is <code>location.reload()</code> blocked during a resize event listener? </p>\n\n<p>Ancient versions of Netscape and IE had really wonky CSS implementations, it was common for them to fail to adapt correctly to window resizes. It became common practice to work around this by triggering a reload on resize. Unfortunately sites with that code <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=201710\">still exist and cause problems</a>. The spec recognises reload-on-resize as an anti-pattern and prevents it.</p>"},{"title":"Downloading webfonts","subtitle":"Is font.woff requested?","lang":"html","expectedRequest":"font.woff","phases":[{"addLines":["<style>","  @font-face {","    font-family: 'myfont';","    src: url('font.woff');","    unicode-range: U+61-7A; /* lowercase a-z */","  }","</style>"]},{"removeLines":1,"addLines":["  p {","    font-family: myfont, sans-serif;","  }","</style>"]},{"addLines":["<p></p>"]},{"removeLines":1,"addLines":["<p>HI THERE!!</p>"]},{"removeLines":1,"addLines":["<p>Hi THERE!!</p>"]}],"id":"webfont-range","answer":{"chrome":3,"opera":2,"firefox":2,"ie":2},"explanation":"<p>From <a href=\"http://www.w3.org/TR/css3-fonts/#font-face-loading\">the spec</a>:</p>\n\n<blockquote>\n  <p>User agents that download all fonts defined in @font-face rules without considering whether those fonts are in fact used within a page are considered non-conformant</p>\n</blockquote>\n\n<p>…but 'consider' is such a fluffy word.</p>\n\n<blockquote>\n  <p>In cases where a font might be downloaded in character fallback cases, user agents may download a font if it's listed in a font list but is not actually used for a given text run.</p>\n</blockquote>\n\n<p>…so all the browsers are doing it right, but Chrome is arguably a little better optimised.</p>\n\n<p>I say 'a little', because we've told the browser up-front that <code>font.woff</code> only contains lowercase a-z glyphs, so there's an easy optimisation that's being passed up by all browsers.</p>\n\n<p>Previous versions of the spec didn't allow browsers to download fonts unless a glyph from them was needed, this was relaxed in late 2011.</p>"}]