[{"title":"Simple image element","lang":"html","expectedRequest":"img.png","phases":[{"addLines":["<p>Download img.png</p>"],"explanation":"<p>Of course not. That'd be insane.</p>"},{"removeLines":1,"addLines":["<p>No, seriously, download img.png</p>"],"explanation":"<p>Ok ok, I think you're getting the hang of the buttons. Let's get serious…</p>"},{"removeLines":1,"addLines":["<image href=\"img.png\">"],"explanation":"<p>Ok, I'm being slightly sneaky here. Most browsers treat <code>&lt;image&gt;</code> as an alias of <code>&lt;img&gt;</code>, but it won't work with <code>href</code>.</p>"},{"removeLines":1,"addLines":["<div style=\"display: none\"><img src=\"img.png\"></div>"],"explanation":"<p>Aha! Yes, browsers download imagery regardless of style, <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/embedded-content-1.html#dfnReturnLink-0\">as per the spec</a>.</p>\n\n<p>This behaviour has been the downfall of many JavaScript implementations of adaptive imagery, as the original image gets requested before JavaScript can jump in and alter the <code>src</code> property.</p>"}],"id":"img-element","answer":{"chrome":3,"safari":3,"firefox":3,"ie":3}},{"title":"Background Images","lang":"html","expectedRequest":"img.png","phases":[{"addLines":["<div style=\"display:none\">","  <div style=\"background: url(img.png)\"></div>","</div>"],"explanation":"<p>Yes, CSS background images differ from <code>img</code> elements, they aren't downloaded as soon as the element is parsed.</p>\n\n<p>If an element has <code>display: none</code>, calculating styles within that element is a waste of time since have no impact on the rendering of the document (they're not displayed), so background images on child elements are never calculated and therefore not downloaded.</p>"},{"removeLines":3,"addLines":["<div style=\"background: url(img.png); display: none\"></div>"],"explanation":"<p>Did I mention that browsers do stuff differently from each other? I think I did.</p>\n\n<p>So, here the div isn't rendered, but it needs to have its style calculated in order to discover that. Turns out IE &amp; Chrome queue downloads when styles are resolved. You could argue they're jumping the gun a bit here.</p>"},{"removeLines":1,"addLines":["<div style=\"background: url(img.png); visibility: hidden\"></div>"],"explanation":"<p>Elements with <code>visibility: hidden</code> still have their style computed and retain their space on the page. This layout process triggers the download in Firefox.</p>\n\n<p>Ok, let's get JavaScript involved…</p>"}],"id":"divbg-element","answer":{"chrome":1,"safari":1,"firefox":2,"ie":1}},{"title":"Creating an image element with js","lang":"js","expectedRequest":"img.png","phases":[{"addLines":["var img = document.createElement('img');","img.src = 'img.png';"],"explanation":"<p>Yep, img elements simply can't wait to make requests.</p>\n\n<p><code>img</code> sources are downloaded <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/embedded-content-1.html#dfnReturnLink-0\">as soon as their <code>src</code> attribute is set</a>. There's no requirement for them to be in a document.</p>\n\n<p>If you need to quickly trigger an http request and don't care about the response, you can do so with <code>new Image().src = url;</code>.</p>"}],"id":"img-add","answer":{"chrome":0,"safari":0,"firefox":0,"ie":0}},{"title":"Elements with background images created via script","lang":"js","expectedRequest":"img.png","phases":[{"addLines":["var div = document.createElement('div');","div.style.background = 'url(img.png)';"],"explanation":"<p>As we saw with plain HTML, background images aren't downloaded until their styles resolve. That's not going to happen while the element isn't in the document.</p>"},{"addLines":["document.body.appendChild(div);","document.body.removeChild(div);"],"explanation":"<p>Indeed, the single-threaded nature of JavaScript and the DOM means the element is added and removed before the part of the browser that deals with styles &amp; rendering sees it.</p>"},{"removeLines":1,"addLines":["div.style.background;","document.body.removeChild(div);"]},{"removeLines":2,"addLines":["div.innerHTML;","document.body.removeChild(div);"],"explanation":"<p>Aha, so Internet Explorer triggers the request here because… y'know… actually I have no idea. It just does. Ok?</p>"},{"removeLines":2,"addLines":["div.offsetWidth;","document.body.removeChild(div);"],"explanation":"<p>To get the width of an element the browser has to resolve its styles and calculate layout. As we saw earlier, this triggers background images to download.</p>"}],"id":"divbg-add","answer":{"chrome":4,"safari":4,"firefox":4,"ie":3}},{"title":"Script elements","lang":"html","expectedRequest":"script.js","phases":[{"addLines":["<script src=\"script.js\" type=\"foo/bar\"></script>"],"explanation":"<p>None of the browsers parse scripts of a type/language they don't recognise, but Firefox &amp; IE <em>will</em> download the file regardless of type.</p>\n\n<p><a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#script-processing-prepare\">The HTML spec</a> instructs browsers to ignore script elements with an unsupported type, so \"boo hiss\" to the browsers that start downloads here.</p>\n\n<p>Interestingly, <a href=\"http://blog.getify.com/on-script-loaders/\">some script preloaders relied on browsers downloading unrecognised script types</a> in order to populate the cache, which no longer works.</p>"},{"removeLines":1,"addLines":["<script src=\"script.js\" type=\"script/dart\"></script>"],"explanation":"<p>Heh, no, that hasn't made it into the browser yet.</p>"},{"removeLines":1,"addLines":["<script src=\"script.js\" type=\"text/html\"></script>"],"explanation":"<p>Although <code>text/html</code> is a supported type, it isn't a supported script type, so no downloady.</p>"},{"removeLines":1,"addLines":["<script src=\"script.js\" LANGUAGE=DART></script>"],"explanation":"<p>Still no Dart in the browser.</p>"},{"removeLines":1,"addLines":["<script src=\"script.js\"></script>"],"explanation":"<p>Finally!</p>\n\n<p>If a script element lacks a type/language attribute, <code>text/javascript</code> is assumed. This is common browser behaviour and was <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#script-processing-prepare\">later added to the HTML spec</a>.</p>"}],"id":"script-element","answer":{"chrome":4,"safari":4,"firefox":0,"ie":0}},{"title":"Dynamic script loading","lang":"js","expectedRequest":"script.js","phases":[{"addLines":["var script = document.createElement('script');","script.href = 'script.js';"],"explanation":"<p>Of course, <code>href</code> isn't a recognised property of script elements.</p>"},{"removeLines":1,"addLines":["script.src = 'script.js';"],"explanation":"<p>Ahh the joys of cross-browser development! Here's what <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#dfnReturnLink-0\">the spec</a> has to say:</p>\n\n<blockquote>\n  <p>When a script element … experiences one of the events listed … the user agent must synchronously prepare the script element:</p>\n  \n  <p>The script element gets inserted into a document…</p>\n</blockquote>\n\n<p>Script preparation involves triggering the request.</p>\n\n<p>IE is violating the spec by triggering the request before the script is inserted into the document, although this does give the developer control over script downloading and parsing separately.</p>"},{"addLines":["document.body.appendChild(script);","document.body.removeChild(script);"],"explanation":"<p>Yep! Looking at the spec again:</p>\n\n<blockquote>\n  <p>When a script element … experiences one of the events listed … the user agent must synchronously prepare the script element:</p>\n  \n  <p>The script element gets inserted into a document…</p>\n</blockquote>\n\n<p>The script preparation is synchronous, it shouldn't wait for layout or the end of execution. </p>"}],"id":"script-add","answer":{"chrome":2,"safari":2,"firefox":2,"ie":1}},{"title":"Creating a link element via script","lang":"js","expectedRequest":"style.css","phases":[{"addLines":["var link = document.createElement('link');","link.rel = 'stylesheet';","link.href = 'style.css';"],"explanation":"<p>Uh huh! No requests here. According to <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/links.html#link-type-stylesheet\">the spec</a>…</p>\n\n<blockquote>\n  <p>The appropriate time to obtain the resource is when the external resource link is created or when its element is inserted into a document, whichever happens last.</p>\n</blockquote>\n\n<p>…so we wouldn't expect to see a request before the <code>link</code> was added to the document.</p>"},{"addLines":["link.type = 'text/javascript';","document.body.appendChild(link);"],"explanation":"<p>What? The specification doesn't cover what to do if the content-type is unsupported for styles, but it's unexpected to see Chrome making the request at this point. Note: it doesn't parse the styles, it just downloads the file. Pfft.</p>"},{"removeLines":2,"addLines":["document.body.appendChild(link);","document.body.removeChild(link);"],"explanation":"<blockquote>\n  <p>The default type for resources given by the stylesheet keyword is text/css.</p>\n</blockquote>\n\n<p>…so the lack of a <code>type</code> attribute doesn't prevent downloading. </p>\n\n<p>Also, like scripts, queuing the download is a synchronous action, so removing the element straight away doesn't prevent downloading.</p>"}],"id":"style-add","answer":{"chrome":1,"safari":1,"firefox":2,"ie":2}},{"title":"The joy of iframes","requestDesc":"anything from the host domain (assuming the host page location is /index.html?search=stuff)","lang":"html","expectedRequest":"#","phases":[{"addLines":["<iframe></iframe>"],"explanation":"<p>Yeah, well, welcome to iframes.</p>\n\n<p>The <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/the-iframe-element.html#process-the-iframe-attributes\">spec is clear</a> about handling iframes without a src:</p>\n\n<blockquote>\n  <p>if the element has no src attribute specified… fire a simple event named load at the iframe element.</p>\n</blockquote>\n\n<p>And that's all. A load event is fired even though nothing is loaded.</p>"},{"removeLines":1,"addLines":["<iframe src=\"\"></iframe>"],"explanation":"<p>Continuing with the spec:</p>\n\n<blockquote>\n  <p>Otherwise if the value of the src attribute is the empty string, let url be the string \"about:blank\".</p>\n</blockquote>\n\n<p>…so no requests here either.</p>"},{"removeLines":1,"addLines":["<iframe src=\"#\"></iframe>"],"explanation":"<p>More spec reading:</p>\n\n<blockquote>\n  <p>Otherwise, resolve the value of the src attribute, relative to the iframe element.</p>\n</blockquote>\n\n<p>Riiiight, so that sounds like it should make a request here.</p>\n\n<blockquote>\n  <p>If there exists an ancestor browsing context whose active document's address, ignoring fragment identifiers, is equal to url, then abort these steps.</p>\n</blockquote>\n\n<p>Ah, so no, there shouldn't be a request here. Chrome violates this part of the spec. \"#\" is the same url as the parent window if the fragment identifier is ignored.</p>"},{"removeLines":1,"addLines":["<iframe src=\"?\"></iframe>"],"explanation":"<p>\"?\" is a different url to the parent window, so a request is triggered. Done.</p>"}],"id":"iframe-element","answer":{"chrome":2,"safari":2,"firefox":3,"ie":3}},{"title":"Altering the DOM with document.write","lang":"html","expectedRequest":"img.png","phases":[{"addLines":["<script>document.write('<'+'!--')</script>","<img src=\"img.png\">","-->"],"explanation":"<p>Oof, sorry, that was a tricky one.</p>\n\n<p>If an HTML comment is written, the <code>img</code> element isn't parsed &amp; therefore shouldn't download. However, some browsers optimise by looking ahead and identifying extra requests to make, reducing the performance impact of elements that block parsing, such as inline scripts. This is known as <a href=\"https://developer.mozilla.org/en-US/docs/HTML/Optimizing_Your_Pages_for_Speculative_Parsing\">speculative parsing</a>.</p>\n\n<p>Firefox and IE continue to parse the document while the script is executing, they pick up the <code>img</code> and trigger a request. The script finishes and the speculative parsing work is discarded along with the <code>img</code> element, an html comment is created in its place, but the request has already been made.</p>\n\n<p>Chrome also scans ahead while blocked by external scripts, but not in the case of inline scripts.</p>"},{"removeLines":3,"addLines":["<script async>document.write('<'+'!--')</script>","<img src=\"img.png\">","-->"]},{"removeLines":3,"addLines":["<script defer>document.write('<'+'!--')</script>","<img src=\"img.png\">","-->"],"explanation":"<p>The <code>async</code> and <code>defer</code> attributes <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/scripting-1.html#script-processing-defer\">have no effect</a> on inline scripts. They were just to throw you off the scent. Sorry.</p>"},{"removeLines":2,"addLines":["-->","<img src=\"img.png\">","-->"]}],"id":"script-comment","answer":{"chrome":3,"safari":3,"firefox":0,"ie":0}},{"title":"Reloading the page","requestDesc":"the current page (a reload without user interaction)","lang":"js","expectedRequest":"#","phases":[{"addLines":["window.onresize = function() {","  window.location.reload();","};"],"explanation":"<p>Yeah, that'd be mad.</p>"},{"addLines":["var event = document.createEvent('Event');","event.initEvent('resize', false, false);","window.dispatchEvent(event);"],"explanation":"<p>This seems straight forward at first. Triggering the resize event should cause the page to reload right? No, this is a <a href=\"http://www.whatwg.org/specs/web-apps/current-work/multipage/history.html#dom-location-reload\">spec violation</a>!</p>\n\n<blockquote>\n  <p>When the reload() method is invoked … If the currently executing task is the dispatch of a resize event in response to the user resizing the browsing context … Repaint the browsing context and abort these steps.</p>\n</blockquote>\n\n<p>Although the test isn't strictly 'in response to the user resizing', the results are the same as if they were.</p>\n\n<p>So, why is <code>location.reload()</code> blocked during a resize event listener? </p>\n\n<p>Ancient versions of Netscape and IE had really wonky CSS implementations, it was common for them to fail to adapt correctly to window resizes. It became common practice to work around this by triggering a reload on resize. Unfortunately sites with that code <a href=\"https://bugzilla.mozilla.org/show_bug.cgi?id=201710\">still exist and cause problems</a>. The spec recognises reload-on-resize as an anti-pattern and prevents it.</p>"},{"removeLines":3,"addLines":["window.onresize();"],"explanation":"<p>Yep, this is just calling a function, so it works.</p>"}],"id":"resize-reload","answer":{"chrome":1,"safari":1,"firefox":2,"ie":0}},{"title":"Downloading webfonts","lang":"html","expectedRequest":"font.woff","phases":[{"addLines":["<style>","  @font-face {","    font-family: 'myfont';","    src: url('font.woff');","    unicode-range: U+61-7A; /* lowercase a-z */","  }","</style>"]},{"removeLines":1,"addLines":["  p {","    font-family: myfont, sans-serif;","  }","</style>"],"explanation":"<p>From <a href=\"http://www.w3.org/TR/css3-fonts/#font-face-loading\">the spec</a>:</p>\n\n<blockquote>\n  <p>User agents that download all fonts defined in @font-face rules without considering whether those fonts are in fact used within a page are considered non-conformant</p>\n</blockquote>\n\n<p>This is something IE&lt;9 got wrong, but everyone's sensible now. The browser must \"consider\" if the fonts are used.</p>\n\n<p>…but 'consider' is such a fluffy word. This next one's a puzzler…</p>"},{"addLines":["<p></p>"],"explanation":"<p>One could say that Firefox &amp; IE aren't considering things quite enough here, but they're not violating the spec.</p>"},{"removeLines":1,"addLines":["<p>HI THERE!!</p>"],"explanation":"<p>Chrome is arguably a little better optimised.</p>\n\n<p>I say 'a little', because we've told the browser up-front that <code>font.woff</code> only contains lowercase a-z glyphs, so there's an easy optimisation that's being passed up by all browsers.</p>\n\n<p>Previous versions of the spec didn't allow browsers to download fonts unless a glyph from them was needed, this was relaxed in late 2011.</p>"}],"id":"webfont-range","answer":{"chrome":3,"safari":3,"firefox":2,"ie":2}}]